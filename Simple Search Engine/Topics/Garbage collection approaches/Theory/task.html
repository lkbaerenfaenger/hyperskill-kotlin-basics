<h2>Garbage collection approaches</h2>
<html><body><p>In the previous topic, we mentioned that garbage collection can be performed in fixed time intervals or when there is no heap memory left. The garbage collector is a rather complex mechanism that consumes a lot of resources. If garbage collection starts as soon as any unused object appears, this process will consume more resources than just storing the object would. Therefore, the JVM executes it only when garbage collection is considered necessary.<br/>
We will start by discussing a few ways of finding unnecessary objects and learn what <strong>object generation</strong> means and how this mechanism classifies objects. We will also tell you about the pitfalls of automatic garbage collection and about the tools developers can use to monitor the execution of a program.</p>
<p></p><div class="alert alert-primary">In this topic, by the JVM we mean the HotSpot JVM, which is used by the open-source version of Java Standard.</div><p></p>
<h5 id="how-to-find-unused-objects">How to find unused objects</h5>
<p>To remove garbage from memory, the GC needs to know which objects are dead. The idea is quite simple and clear, but in fact, it is a rather complex process based on various algorithms. In this section, we will tell you about two approaches to locating unused objects:</p>
<ul>
<li><strong>Reference counting</strong>. The idea of this approach is that each object is assigned a field showing the number of references pointing to it. Adding a reference increases its value by 1, and removing a reference decreases its value by 1.<img alt="" height="267" name="Counting.svg" src="https://ucarecdn.com/6d7b6b18-e4c2-4fd4-9820-4d9e0f967a0b/" width="546"/><br/>
	Reference counting allows the collector to delete an object as soon as the counter value is zero, although this may not always be the right decision. This feature is one of the advantages of reference counting, but it also has some disadvantages. The application consumes memory to store the field for the reference counter, and its performance is reduced due to operations to increase or decrease the field value. Another important disadvantage is difficulties in finding circular references: when two objects refer only to each other, they may be invisible to the collector because their reference counter will never become 0.</li>
<li><strong>Tracing</strong>. This approach is more common than reference counting; in fact, JVM uses only tracing algorithms for garbage collectors. The tracing algorithm finds referenced objects, marks them, and writes off the rest as garbage. The search starts with objects known as <strong>GC Roots</strong> and builds a chain of related objects. Typical GC Root objects are <strong>local variables </strong>and<strong> method parameters</strong>, <strong>threads</strong>, <strong>static variables</strong>. In the image below, the blue circles represent chains of live objects, and the white ones represent dead objects, where the connection between <em>a</em> and <em>b </em>is an example of a circular reference.
	<p style="text-align: center;"><img alt="" height="475" name="Tracing.svg" src="https://ucarecdn.com/da4ea5d4-6b17-4db1-a3c3-e7c14d2cccfd/" width="444"/></p>
<br/>
	An important advantage over the previous method is the possibility to find circular references but in this case, the garbage collector needs to wait until the algorithm finds all livе objects before it starts removing dead ones.</li>
</ul>
<p>Simply put, reference counting and tracing are two opposites: the first tracks dead objects and the second tracks live ones. All algorithms performing garbage collection use these two approaches. Some prefer one of them, and some others use both. </p>
<h5 id="memory-cleanup-generational-hypothesis">Memory cleanup: generational hypothesis</h5>
<p>The generational mechanism is a common strategy for garbage collectors. It works by dividing objects into groups (generations), and if cleaning one group frees up enough memory, the collector does not clean the others, saving time and resources. As for the JVM, it has both generational and non-generational garbage collectors. For instance, <a href="https://www.youtube.com/watch?v=OhPGN2Av44E" rel="noopener noreferrer nofollow" target="_blank">G1</a> (Garbage First) uses a generational approach, and <a href="https://www.youtube.com/watch?v=kF_r3GE3zOo" rel="noopener noreferrer nofollow" target="_blank">ZGC</a> does not.</p>
<p>This approach divides objects into generations, depending on how many garbage collections they have survived. Memory cleanup starts with the youngest generation, where all new objects are. The reason for that is that the experience and statistics collected over the years have formed the <strong>generational hypothesis</strong>, which states that most objects die young. Therefore, GC must start garbage collection from the place where the youngest objects are stored. Objects surviving the garbage collection move to the next generation. In the second generation, the garbage collection is performed only when cleaning the first one does not free up enough memory. That is, the cleaning of each generation is carried out when the cleaning of all previous ones does not free up enough memory, and the objects that survived the cleaning move to the next generation. This way, passing through all generations, objects can reach the last one and remain there if the garbage collector does not delete them.</p>
<p><img alt="" height="433" name="1_(7).svg" src="https://ucarecdn.com/32a59da8-7361-4213-b9a2-9ed1bf973611/" width="628"/></p>
<p></p><div class="alert alert-primary">In addition to dividing objects into generations, there is another approach to organizing the memory management process – the division of memory into regions, where old and new objects can be stored in the same region. Java has GCs that use only this approach. It is also possible to use both of them in the same collector.</div><p></p>
<h5 id="automated-garbage-collection-pitfalls">Automated garbage collection pitfalls</h5>
<p>While automatic garbage collection makes programming easier and speeds up application development, it also has its downsides. Among them are:</p>
<ul>
<li><strong>Resource consumption</strong> (memory, CPU). Automatic garbage collection consumes a lot of CPU and memory resources. This is the main reason why programming languages with manual memory management such as C++ work faster. In C++ developers control memory management themselves, and the application does not need to spend resources on it.</li>
<li><strong>Latency</strong>. All implementations of JVM garbage collectors have the so-called stop-the-world mechanism requiring applications to pause. It is a period when new objects are not created and garbage collection is run. Тhe longer this pause, the slower the application will run.</li>
<li><strong>Memory fragmentation</strong>. After dead objects removal, the memory areas where they were located remain unused. Therefore, after garbage collection, objects are overwritten next to each other to remove the extra space. Of course, this process also affects the performance of the application.</li>
</ul>
<p>Java developers have a set of tools to monitor the execution and performance of the program and get statistics. Some examples of such tools are <a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html" rel="noopener noreferrer nofollow" target="_blank">jstat</a> or <a href="https://www.oracle.com/java/technologies/jdk-mission-control.html" rel="noopener noreferrer nofollow" target="_blank">Java Mission Control</a>, shipped with Java, or third-party applications like <a href="https://visualvm.github.io/index.html" rel="noopener noreferrer nofollow" target="_blank">VisualVM</a> and <a href="https://www.ej-technologies.com/products/jprofiler/overview.html" rel="noopener noreferrer nofollow" target="_blank">JProfiler</a>. Study these and other tools carefully. They will give you valuable benefits.</p>
<h5 id="conclusion">Conclusion</h5>
<p>Although it is assumed that Java carries out garbage collection automatically, this is not quite true. First of all, the Java platform uses several GCs and each of them has its own ways of performing memory management. Developers can choose the one that suits their needs best. Besides that, there are options to make various settings to configure GC's memory management process and control it. </p></body></html>
