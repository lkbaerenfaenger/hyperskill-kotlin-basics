<h2>Exceptions and resources</h2>
<p>We have already learned how we can handle exceptions with the <strong>try-catch </strong>and <strong>try-catch-finally </strong>statements<strong>. </strong>Sometimes, we may need to work with different resources, like files, sockets, database connections, etc., and exceptions may occur in those cases, too.<strong> </strong>In this topic, we will explain how to handle exceptions while working with outside resources.</p><h5 id="working-with-resources">Working with resources</h5><p>A resource is data which can be accessed by an application. Kotlin is a platform-independent programming language, and it lets you directly control only variables and objects but not computer memory and its objects, such as files, sockets, databases, etc. Kotlin provides methods to access operating system resources through the JVM. </p><p>For example, when we work with files (read file, write into file, etc.), an IO stream is created. The JVM notifies the operating system (OS) about starting the work with a file, and if everything is fine, the OS will return the file descriptor, which is used to access the file. In order to use input and output streams, you should import the following package:</p><pre><code class="language-kotlin">import java.io.*</code></pre><p>Let's look at the example below: </p><pre><code class="language-kotlin">var reader = FileReader("somefile.txt")
val text = reader.readText()
reader.close()</code></pre><p>Here, we create an instance of <code class="language-kotlin">FileReader</code> from the <code class="language-kotlin">java.io</code> package, which provides classes and their methods for reading and writing data. <code class="language-kotlin">FileReader</code> is used to read text data from the file identified by the path <code class="language-kotlin">String</code>. When we create an instance of <code class="language-kotlin">FileReader</code>, we open an input stream for reading data from a file.</p><p>If you want to write something into a file, you should use <code class="language-kotlin">FileWriter</code>; below you can see an example:</p><pre><code class="language-kotlin">val writer = FileWriter("somefile.txt")
writer.write("hello!")
writer.close()</code></pre><p>The <code class="language-kotlin">close()</code> method is used by the JVM to release resources. If we talk about files, the OS can provide a limited number of file descriptors. If we keep creating resources without releasing them, an exception may occur because of the lack of memory. That is why resources like <code class="language-kotlin">FileReader</code>, <code class="language-kotlin">BufferedReader</code>, <code class="language-kotlin">Socket</code>, etc. must be closed when they are <strong>not used </strong>any longer. </p><p>However, something can go wrong after declaring certain resources, and exceptions can be thrown. It means that <code class="language-kotlin">close()</code> isn't called and system resources are not released. </p><h5 id="get-familiar-with-use">Get familiar with use()</h5><p>Luckily, the above problem with resources can be solved by the <code class="language-kotlin">use()</code> method, which  manages resources automatically. Let's modify our example :</p><pre><code class="language-kotlin">val reader = FileReader("test.txt")
reader.use {
    reader.read()
}</code></pre><p>The method takes a functional expression, executes it, and, by calling <strong>close() </strong>on it, releases resources every time the execution is completed – no matter with or without an exception.</p><p>We can use a shorter form with a lambda expression:</p><pre><code class="language-kotlin">FileReader("test.txt").use { reader -&gt; reader.read() }</code></pre><p>Or otherwise, we can use the implicit variable <code class="language-kotlin">it</code> inside the block:</p><pre><code class="language-kotlin">FileWriter("test.txt").use { it.write("something") }
</code></pre><p>The <code class="language-kotlin">use()</code> function refers only to JVM Kotllin, i.e., Kotlin code which compiles into JVM bytecode and can be run on the JVM.</p><h5 id="closeable-vs-autocloseable">Closeable vs AutoCloseable</h5><p><code class="language-kotlin">Closeable</code> and <code class="language-kotlin">AutoCloseable</code> interfaces introduce objects which may hold resources (such as file or socket handles) until the resource is closed. The function <code class="language-kotlin">use()</code> is defined in both interfaces, and after we invoke it, <code class="language-kotlin">close()</code> is called automatically when exiting a try-with-resources block. <code class="language-kotlin">Closeable</code> is an older interface, but it still extends <code class="language-kotlin">AutoCloseable</code> for the sake of backward compatibility.</p><p>The main difference between <code class="language-kotlin">Closeable</code> and<code class="language-kotlin"> AutoCloseable</code> is that the former has a limited exception type – it can throw only <code class="language-kotlin">IOException</code> and its inheritors. Meanwhile, in <code class="language-kotlin">AutoCloseable</code> the exception range has been expanded to <code class="language-kotlin">Exception</code>.</p><p>We can invoke the <code class="language-kotlin">use</code> function on any object which implements <code class="language-kotlin">AutoCloseable</code> or <code class="language-kotlin">Closeable</code>, but <code class="language-kotlin">AutoCloseable</code> is newer and more flexible.</p><p>Let's try to implement the <code class="language-kotlin">AutoCloseable</code> interface and override its function <code class="language-kotlin">close()</code>. The implementation of <code class="language-kotlin">Closeable</code> will look similar.</p><pre><code class="language-kotlin">class SomeResource : AutoCloseable {
    override fun close() {
        // close resource
    }
}</code></pre><p><code class="language-kotlin">close()</code> in the <code class="language-kotlin">Closeable</code> interface throws <code class="language-kotlin">IOException</code>, so it can't process other classes of exceptions. The <code class="language-kotlin">close()</code> function from <code class="language-kotlin">AutoCloseable</code> throws <code class="language-kotlin">Exception</code>, so, as you can see, the range of exceptions which can be processed by our class <code class="language-kotlin">OtherResource</code> is wider, which can be an argument in favour of using the <code class="language-kotlin">AutoCloseable</code> interface.</p><p>There are a lot of classes and interfaces which implement or extend the <code class="language-kotlin">AutoCloseable</code> interface, you can find them in the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html" rel="noopener noreferrer nofollow" target="_blank">AutoCloseable documentation</a>.</p><h5 id="conclusion">Conclusion </h5><p>Resources associated with files, databases, and other information sources must be released after they finishing their work; otherwise, we can exceed the memory limit. We've learned about try-with-resources constructions, which help us to handle exceptions from IO streams. Kotlin has its own concise and clear <code class="language-kotlin">use</code> function for automatically managing resources. Don't forget to use it while managing system resources. We've also learned about two interfaces: <code class="language-kotlin">AutoCloseable</code> and <code class="language-kotlin">Closeable</code>, which are used for releasing resources. <code class="language-kotlin">Closeable</code> is an older interface, and it still exists for the sake of backward compatibility, while <code class="language-kotlin">AutoCloseable</code> is more preferable due to its flexibility.</p>
