<h2>Queue</h2>
<p>Most people that keep a daily planner are used to doing things in the order in which they write them there. All of us have stood in line at the store checkout at some point. Chefs put ingredients in a dish sequentially in the order they are specified in the recipe. Everyone knows the concept of a <strong>queue</strong>, because it is an intuitive sequence of actions: we perform what comes first, and then we do the next task. Thus, you can safely forget about what you have already done, so while performing a task, you are focused only on it, not on previous or following ones. The queue works on the <strong>FIFO principle</strong>,<strong> </strong>which means <strong>F</strong>irst <strong>I</strong>n, <strong>F</strong>irst <strong>O</strong>ut.</p><p>It is convenient to perform actions as they arrive not only in real life, but also in programming. Let's figure out exactly how queues are defined in computer science and in which cases they are flexible to use.</p><h5 id="fifo-and-queues">FIFO and Queues</h5><p>Even if you do opt for an easier word "line", you still probably know what a <strong>queue</strong> is: according to the Cambridge Dictionary, it is "a row of people waiting for something, one behind the other". Let's imagine a queue as a line of people in a movie theater. The first one in line is the first one to enter the theater: first come first served, as we sometimes say in life. This is exactly how the FIFO principle works when we're talking about queues in programming.</p><p style="text-align: center;"><img alt="" height="814" src="https://ucarecdn.com/0a761e30-d73c-4d17-bc89-d3d7909c1125/" width="1600"/></p><p>Formally, First In, First Out principle, commonly known as <strong>FIFO</strong>, is taken from economics, where it defines a method in which products produced or acquired first are sold, used, or disposed of first. As the name of the method supposes, there are two main operations in First In, First Out principle: In and Out themselves. So if we want to add an element, we perform some kind of insertion<em> </em>operation, and if we want to exclude an element from the storage, we use deletion.</p><p>There are a few more data structures close to queue, such as deque, circular queue, or priority queue. However, the focus of this topic is a simple queue, and we will return to more complex queues in the following topics.</p><h5 id="queue-operations">Queue operations</h5><p>A <strong>queue</strong> is a fundamental data structure with two basic operations: </p><ul><li><p><strong>enqueue</strong> inserts an element;</p></li><li><p><strong>dequeue</strong> removes an element.</p></li></ul><p>Elements are inserted at the end of a queue and removed from the top of it.</p><p style="text-align: center;"><img alt="" height="482" src="https://ucarecdn.com/971a7192-5424-4cfe-9fd2-047618967fb9/" width="1600"/></p><p>Here, element<strong> </strong>1 was added before any other, and hence it will be dequeued first. At the same time, element 4 was added last, which means it is last to be dequeued.</p><p>Since we insert elements at the end and delete them strictly from the top of a queue, the complexity of performing these operations is <span class="math-tex">\(O(1)\)</span>. To find an item in the queue, you will need to perform a number of operations that directly depends on the number of items in the queue. So, it is <span class="math-tex">\(O(n)\)</span>.</p><p></p><div class="alert alert-primary"><p>Insertion of elements into the queue occurs sequentially, element by element. The first queue element, i.e. the last element that has been added to the queue, is called the head, and the endmost one is called the tail. The elements are removed in reverse order, starting from the tail.</p></div><p></p><h5 id="realization-of-queue">Realization of queue</h5><p>It's not in all programming languages that we can define a queue. However, there are several ways to implement queues.</p><p><strong>Array</strong></p><p>A queue can be represented in the form of a fixed-size array and two integer variables: <span class="math-tex">\(start\)</span> and <span class="math-tex">\(end\)</span>. Usually, <span class="math-tex">\(start\)</span> points to the head of the queue, while <span class="math-tex">\(end\)</span> to the element that will be filled when a new element enters the queue.</p><p><img alt="" height="312" src="https://ucarecdn.com/1edc36f9-364b-40e5-945c-4f325186ac69/" width="812"/></p><p>When we add an item to the queue, the new item is put to <span class="math-tex">\(q[end]\)</span>, and the <span class="math-tex">\(end\)</span> is decreased by one. If the value of <span class="math-tex">\(end\)</span> becomes less than 1, the value of the variable becomes equal to <span class="math-tex">\(n\)</span>.</p><p>The extraction of an element from the queue is performed in the same way: after extracting the element <span class="math-tex">\(q[start]\)</span> from the queue, the variable <span class="math-tex">\(start\)</span> is decreased by 1. With such algorithms, one cell out of <span class="math-tex">\(n\)</span> will always be unoccupied (since a queue with <span class="math-tex">\(n\)</span> elements cannot be distinguished from an empty one).</p><p>Let's take a look at an example. At first, we have just one element in the queue. However, the queue is already determined to have 4 cells. <span class="math-tex">\(start\)</span> is zero and <span class="math-tex">\(end\)</span> equals to queue's size.</p><p><img alt="" height="167" src="https://ucarecdn.com/6d9d03ba-442e-4ae4-b57e-dbd109d86e31/" width="574"/></p><p>While adding new elements, <span class="math-tex">\(end\)</span> will be decreased and <span class="math-tex">\(start\)</span> remains the same until we delete an element.</p><p><img alt="" height="171" src="https://ucarecdn.com/2955c067-c1e2-4801-91ed-935cb441ea2c/" width="554"/></p><p>After two more steps, </p><p><img alt="" height="194" src="https://ucarecdn.com/dd25059a-2bec-495f-b44e-59d71d440e05/" width="562"/></p><p>When we delete elements from the queue, <span class="math-tex">\(start\)</span> will decrease by one.</p><p><img alt="" height="155" src="https://ucarecdn.com/bce50fd8-dd26-4e1f-a5a1-80b596558d45/" width="551"/></p><p>However, this method has a great disadvantage: the maximum number of items in the queue is limited by the size of the array. When it overflows, memory is reallocated and all elements are copied to a new fixed-size array.</p><p><strong>Linked list</strong></p><p>The second method is based on working with dynamic memory. The queue is represented as a linked list, in which the addition or removal of elements goes strictly from its corresponding ends. In this method, the queue size is limited only by the amount of memory, however, more memory is required and working with the queue is somewhat slower.</p><p> </p><p style="text-align: center;"><img alt="" height="160" src="https://ucarecdn.com/a3b2b6b5-705d-4a0f-8ac4-83c06aac4882/" width="1604"/></p><p> </p><h5 id="why-queue">Why queue?</h5><p>We use queues in programming, like in real life, when we need to perform some actions sequentially in the order of their appearance. Below are some examples:</p><ul><li><p>Organization of events in Windows. When a user performs an action, the corresponding procedure is not called in this action's application. However, a message containing information about the action performed is sent to them, this message is queued, and only when the messages that came earlier are processed, the application will perform the necessary action.</p></li><li><p>The operating system uses a queue to store keystroke data as you type on the keyboard. Recall typing something in a text editor while the computer is busy doing another task: the keystrokes still aren't lost. This happens because the system stores them in queue order until they can be processed.</p></li><li><p>Print tasks are stored on a print queue while waiting for printing.</p></li><li><p>Handling website traffic is managed with the help of a queue to process all the incoming requests.</p></li></ul><h5 id="conclusion">Conclusion</h5><p>Queue is a data structure with operations of adding and removing an element. Adding an element, usually denoted by the word enqueue — put in the queue — is possible only at the end of the queue. Deleting, commonly called the word dequeue — remove from the queue — only from the beginning of the queue. Both these operations are processed with <span class="math-tex">\(O(1)\)</span> complexity.</p><p>Often queues are implemented with the help of arrays or linked lists, if it is not defined by the programming language you use. Queues are commonly used in many processes in operating systems and frameworks due to their intuitive understandability.</p><p>Queue is the best choice if you need to handle multiple data instances, and if you need a fast and flexible data structure. However, without knowledge of needed queue size and limited space, in some cases queue is not a good option for performing tasks with insertion or deletion of data.</p>
