content:
- Write, compile, and run
- IDE
- Nested and inner classes
- What is a bug
- IntelliJ IDEA
- IDEA Basics
- Navigation through code
- Writing code with pleasure
- Fixing code
- The concept of patterns
- Introduction to software architecture
- Introduction to creational patterns
- JVM components
- Computer Memory
- Components of computer memory
- Stack and heap memory
- Heap
- Garbage Collector
- Garbage collection approaches
- Design principles
- Single Responsibility Principle
- Singleton
- Object declarations
- Introduction to logging
- Debugging techniques
- Debugging overview
- Debugging simple constructs
- Advanced debugger features
- Self-documenting code
- Fixed-size array
- Dynamic array
- EduTools
- Searching problem
- Linear search
- Binary arithmetic
- Converting from decimal to binary
- Converting from binary to decimal
- 1s Complement
- 2s Complement
- Bitwise and bit-shift operations
- Modulo division
- Modulo division with negative numbers
- IntelliJ Run Configurations
- External resources
- Recursion basics
- Intro to computational thinking
- Components of computational thinking
- How to work with documentation
- Recursion
- Interfaces
- Documentation
- Interface Segregation Principle
- Regexps basics
- Queue
- Kotlin evolution principles
- String formatting
- Floating-point types
- Euclidean division
- Mutable Map
- Set
- Mutable Set
- Iterators
- Collections as interface
- For loop and arrays
- Multi-dimensional array
- Test predicates  checking elements in collection
- Ordering elements in collection
- Filtering elements in collection
- Grouping collections
- Fold and reduce on collections
- Aggregate operations on collections
- Custom sort order for collection
- For loop and iterables
- The try-catch statement
- The try-catch-finally statement
- Exceptions and resources
- Creating custom exceptions
- Function references
- Lambda with receiver
- Scope functions  apply and also
