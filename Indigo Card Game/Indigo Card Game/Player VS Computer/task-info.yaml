type: edu
files:
- name: src/indigo/Main.kt
  visible: true
  text: |-
    package indigo

    fun main() {
        println("Hello World!")
    }
  learner_created: false
- name: test/IndigoCardGameTest.kt
  visible: false
  text: |+
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testing.TestedProgram

    class ErrorData(val correct: Boolean, val errorMsg: String,
                    val topCard: String = "", val cardsList: List<String> = emptyList())

    class CardGameTest : StageTest<Any>() {

        @DynamicTest
        fun playFirstNormalExeTest5(): CheckResult {
            repeat(5) {
                val deck = mutableListOf<String>()
                val cardsInHand = mutableListOf<String>()
                var pointsPlayer = 0
                var pointsComputer = 0
                var pointsOnTable = 0
                var numOfCardsPlayer = 0
                var numOfCardsComputer = 0
                var numOfCardsOnTable = 0
                var whoWon = 0

                val main = TestedProgram()
                var outputString = main.start().trim()
                var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
                if (position == -1) return CheckResult(false, "Wrong game title.")
                position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
                if (position == -1) return CheckResult(false, "Wrong play first prompt.")

                outputString = main.execute("yes").trim()
                var validOutput = checkInitial(outputString)
                if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                deck.addAll(validOutput.cardsList)
                var topCard = validOutput.topCard

                outputString = outputString.substringAfter(topCard).trim()
                numOfCardsOnTable = 4
                pointsOnTable = countPoints(validOutput.cardsList)
                repeat(4) {
                    for (numOfCards in 6 downTo 1) {
                        validOutput = checkPlayerOutput2(outputString, numOfCards, numOfCardsOnTable, topCard)
                        if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                        if (numOfCards == 6) {
                            cardsInHand.clear()
                            cardsInHand.addAll(validOutput.cardsList)
                            for (card in cardsInHand)
                                if (deck.contains(card))
                                    return CheckResult(
                                        false,
                                        "Some cards in hand have already passed on table (Duplicates)."
                                    )
                            deck.addAll(cardsInHand)
                        } else {
                            if (!cardsInHand.containsAll(validOutput.cardsList))
                                return CheckResult(false, "Cards in hand have changed since the last card was played.")
                        }
                        val cardToPlay = chooseCards(validOutput.cardsList, topCard).first()
                        var hasWon = if (numOfCardsOnTable == 0) false
                        else {
                            val a = getRankSuit(topCard)
                            val b = getRankSuit(cardToPlay)
                            a.first == b.first || a.second == b.second
                        }

                        topCard = cardToPlay
                        numOfCardsOnTable++
                        pointsOnTable += countPoints(listOf(topCard))
                        cardsInHand.remove(topCard)
                        outputString = main.execute("${validOutput.cardsList.indexOf(topCard) + 1}").trim()
                        if (hasWon) {
                            whoWon = 0
                            pointsPlayer += pointsOnTable
                            pointsOnTable = 0
                            numOfCardsPlayer += numOfCardsOnTable
                            numOfCardsOnTable = 0
                            topCard = ""
                            position = checkOutput(outputString.lowercase(), 0, "Player wins cards".lowercase())
                            if (position == -1) return CheckResult(false, "Wrong player wins cards message.")
                            position = checkOutput(
                                outputString.lowercase(), position,
                                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase()
                            )
                            if (position == -1) return CheckResult(false, "Wrong score output.")
                            outputString =
                                outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer")
                                    .trim()
                        }

                        validOutput = checkComputerOutput3(outputString, numOfCardsOnTable, topCard, numOfCards)
                        if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                        hasWon = if (numOfCardsOnTable == 0) false
                        else {
                            val a = getRankSuit(topCard)
                            val b = getRankSuit(validOutput.topCard)
                            (a.first == b.first) || (a.second == b.second)
                        }
                        topCard = validOutput.topCard
                        if (deck.contains(topCard))
                            return CheckResult(false, "Computer played card is a duplicate.")
                        deck.add(topCard)
                        numOfCardsOnTable++
                        pointsOnTable += countPoints(listOf(topCard))
                        outputString = outputString.substringAfter(topCard).trim()
                        outputString = outputString.substringAfter(topCard).trim()
                        if (hasWon) {
                            whoWon = 1
                            pointsComputer += pointsOnTable
                            pointsOnTable = 0
                            numOfCardsComputer += numOfCardsOnTable
                            numOfCardsOnTable = 0
                            position = checkOutput(outputString.lowercase(), 0, "Computer wins cards".lowercase())
                            if (position == -1) return CheckResult(false, "Wrong computer wins cards message.")
                            position = checkOutput(
                                outputString.lowercase(), position,
                                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase()
                            )
                            if (position == -1) return CheckResult(false, "Wrong score output.")
                            outputString =
                                outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer")
                                    .trim()
                        }
                    }
                }

                position =
                    if (numOfCardsOnTable == 0) checkOutput(outputString.lowercase(), 0, "No cards on the table".lowercase())
                    else checkOutput(
                        outputString.lowercase(),
                        0,
                        "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase()
                    )
                if (position == -1) return CheckResult(false, "Wrong output for number of cards or the top card.")
                if (whoWon == 0) {
                    pointsPlayer += pointsOnTable
                    numOfCardsPlayer += numOfCardsOnTable
                } else {
                    pointsComputer += pointsOnTable
                    numOfCardsComputer += numOfCardsOnTable
                }
                if (numOfCardsPlayer >= numOfCardsComputer) pointsPlayer += 3
                else pointsComputer += 3
                position = checkOutput(
                    outputString.lowercase(), position,
                    "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                    "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase(),
                    "Game Over".lowercase()
                )
                if (position == -1) return CheckResult(false, "Wrong score output.")
                if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")
            }
            return CheckResult.correct()
        }

        @DynamicTest
        fun playSecondNormalExeTest5(): CheckResult {
            repeat(5) {
                val deck = mutableListOf<String>()
                val cardsInHand = mutableListOf<String>()
                var pointsPlayer = 0
                var pointsComputer = 0
                var pointsOnTable = 0
                var numOfCardsPlayer = 0
                var numOfCardsComputer = 0
                var numOfCardsOnTable = 0
                var whoWon = 0

                val main = TestedProgram()
                var outputString = main.start().trim()
                var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
                if (position == -1) return CheckResult(false, "Wrong game title.")
                position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
                if (position == -1) return CheckResult(false, "Wrong play first prompt.")

                outputString = main.execute("no").trim()
                var validOutput = checkInitial(outputString)
                if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                deck.addAll(validOutput.cardsList)
                var topCard = validOutput.topCard

                outputString = outputString.substringAfter(topCard).trim()
                numOfCardsOnTable = 4
                pointsOnTable = countPoints(validOutput.cardsList)
                repeat(4) {
                    for (numOfCards in 6 downTo 1) {
                        validOutput = checkComputerOutput3(outputString, numOfCardsOnTable, topCard, numOfCards)
                        if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                        var hasWon = if (numOfCardsOnTable == 0) false
                        else {
                            val a = getRankSuit(topCard)
                            val b = getRankSuit(validOutput.topCard)
                            (a.first == b.first) || (a.second == b.second)
                        }
                        topCard = validOutput.topCard
                        if (deck.contains(topCard))
                            return CheckResult(false, "Computer played card is a duplicate.")
                        deck.add(topCard)
                        numOfCardsOnTable++
                        pointsOnTable += countPoints(listOf(topCard))
                        outputString = outputString.substringAfter(topCard).trim()
                        outputString = outputString.substringAfter(topCard).trim()
                        if (hasWon) {
                            whoWon = 1
                            pointsComputer += pointsOnTable
                            pointsOnTable = 0
                            numOfCardsComputer += numOfCardsOnTable
                            numOfCardsOnTable = 0
                            position = checkOutput(outputString.lowercase(), 0, "Computer wins cards".lowercase())
                            if (position == -1) return CheckResult(false, "Wrong computer wins cards message.")
                            position = checkOutput(
                                outputString.lowercase(), position,
                                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase()
                            )
                            if (position == -1) return CheckResult(false, "Wrong score output.")
                            outputString =
                                outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer")
                                    .trim()
                        }

                        validOutput = checkPlayerOutput2(outputString, numOfCards, numOfCardsOnTable, topCard)
                        if (!validOutput.correct) return CheckResult(false, validOutput.errorMsg)
                        if (numOfCards == 6) {
                            cardsInHand.clear()
                            cardsInHand.addAll(validOutput.cardsList)
                            for (card in cardsInHand)
                                if (deck.contains(card))
                                    return CheckResult(
                                        false,
                                        "Some cards in hand have already passed on table (Duplicates)."
                                    )
                            deck.addAll(cardsInHand)
                        } else {
                            if (!cardsInHand.containsAll(validOutput.cardsList))
                                return CheckResult(false, "Cards in hand have changed since the last card was played.")
                        }
                        val cardToPlay = chooseCards(validOutput.cardsList, validOutput.topCard).first()
                        hasWon = if (numOfCardsOnTable == 0) false
                        else {
                            val a = getRankSuit(topCard)
                            val b = getRankSuit(cardToPlay)
                            a.first == b.first || a.second == b.second
                        }

                        topCard = cardToPlay
                        numOfCardsOnTable++
                        pointsOnTable += countPoints(listOf(topCard))
                        cardsInHand.remove(topCard)
                        outputString = main.execute("${validOutput.cardsList.indexOf(topCard) + 1}").trim()
                        if (hasWon) {
                            whoWon = 0
                            pointsPlayer += pointsOnTable
                            pointsOnTable = 0
                            numOfCardsPlayer += numOfCardsOnTable
                            numOfCardsOnTable = 0
                            topCard = ""
                            position = checkOutput(outputString.lowercase(), 0, "Player wins cards".lowercase())
                            if (position == -1) return CheckResult(false, "Wrong player wins cards message.")
                            position = checkOutput(
                                outputString.lowercase(), position,
                                "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                                "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase()
                            )
                            if (position == -1) return CheckResult(false, "Wrong score output.")
                            outputString =
                                outputString.substringAfter("Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer")
                                    .trim()
                        }
                    }
                }

                position =
                    if (numOfCardsOnTable == 0) checkOutput(outputString.lowercase(), 0, "No cards on the table".lowercase())
                    else checkOutput(
                        outputString.lowercase(),
                        0,
                        "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase()
                    )
                if (position == -1) return CheckResult(false, "Wrong output for number of cards or the top card.")
                if (whoWon == 0) {
                    pointsPlayer += pointsOnTable
                    numOfCardsPlayer += numOfCardsOnTable
                } else {
                    pointsComputer += pointsOnTable
                    numOfCardsComputer += numOfCardsOnTable
                }
                if (numOfCardsPlayer >= numOfCardsComputer) pointsPlayer += 3
                else pointsComputer += 3
                position = checkOutput(
                    outputString.lowercase(), position,
                    "Score: Player $pointsPlayer - Computer $pointsComputer".lowercase(),
                    "Cards: Player $numOfCardsPlayer - Computer $numOfCardsComputer".lowercase(),
                    "Game Over".lowercase()
                )
                if (position == -1) return CheckResult(false, "Wrong score output.")
                if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")
            }
            return CheckResult.correct()
        }

        @DynamicTest
        fun playFirstWrongInputTest(): CheckResult {
            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("Hello").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("me").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("0").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("play").trim()
            position = checkOutput(outputString.lowercase(), 0, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output after wrong input after the play first question.")

            outputString = main.execute("yes").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            val topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            validOutput = checkPlayerOutput2(outputString, 6, 4, topCard)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.lowercase(), 0, "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong exit message.")

            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun wrongCardToPlayTest(): CheckResult {
            val main = TestedProgram()
            var outputString = main.start().trim()
            var position = checkOutput(outputString.lowercase(), 0, "Indigo Card Game".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong game title.")
            position = checkOutput(outputString.lowercase(), position, "Play first?".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong play first prompt.")

            outputString = main.execute("yes").trim()
            var validOutput = checkInitial(outputString)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)
            val topCard = validOutput.topCard

            outputString = outputString.substringAfter(topCard).trim()
            validOutput = checkPlayerOutput2(outputString, 6, 4, topCard)
            if ( !validOutput.correct) return CheckResult(false, validOutput.errorMsg)

            outputString = main.execute("0").trim()
            position = checkOutput(outputString.lowercase(), 0, "Choose a card to play (1-6):".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output, after input an invalid card number.")

            outputString = main.execute("7").trim()
            position = checkOutput(outputString.lowercase(), 0, "Choose a card to play (1-6):".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output, after input an invalid card number.")

            outputString = main.execute("One").trim()
            position = checkOutput(outputString.lowercase(), 0, "Choose a card to play (1-6):".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong output, after input an invalid card number.")


            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.lowercase(), 0, "Game Over".lowercase())
            if ( position  == -1 ) return CheckResult(false, "Wrong exit message.")

            if (!main.isFinished) return CheckResult(false, "Application hasn't exited after exit command.")

            return CheckResult.correct()
        }

    }

    fun checkOutput(outputString: String, searchPos: Int, vararg checkStr: String): Int {
        var searchPosition = searchPos
        for (str in checkStr) {
            val findPosition = outputString.indexOf(str, searchPosition)
            if (findPosition == -1) return -1
            if ( outputString.substring(searchPosition until findPosition).isNotBlank() ) return -1
            searchPosition = findPosition + str.length
        }
        return searchPosition
    }

    fun checkOIfValidCards2(cardsStr: String, numOfCards: Int): Boolean {
        val cards = cardsStr.split(" ")
        val cardRegex = "(A|[2-9]|10|J|Q|K)(♦|♥|♠|♣)".toRegex()
        for (card in cards) if (!card.matches(cardRegex)) {
            return false
        }
        return cards.size == numOfCards
    }

    fun checkIfUniqueCards(outputString: String): Boolean {
        val lines = outputString.lines()
        val cards = lines.first().trim().split(" ")
        return cards.distinct().size == cards.size
    }

    fun checkOIfValidCardsInHand(cardsStr: String, numOfCards: Int): Boolean {
        val cards = cardsStr.split(" ")
        val cardRegex = "([1-6])\\)(A|[2-9]|10|J|Q|K)(♦|♥|♠|♣)".toRegex()
        for (card in cards) if (!card.matches(cardRegex)) {
            return false
        }
        return cards.size == numOfCards
    }

    fun checkInitial(output: String): ErrorData {
        val position = checkOutput(output.lowercase(), 0, "Initial cards on the table:".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong Initial cards message.")
        val cardsStr = output.substring(position).lines().map { it.trim() }.first { it != "" }
        if (cardsStr.isEmpty()) return ErrorData(false, "No initial cards are printed.")
        if ( !checkOIfValidCards2(cardsStr, 4) ) return ErrorData(false, "Invalid initial cards.")
        if ( !checkIfUniqueCards(cardsStr) ) return ErrorData(false, "Initial cards contain duplicate cards.")
        val cardsOnTable = cardsStr.trim().split(" ")
        val topCard = cardsOnTable.last()
        return ErrorData(true, "", topCard, cardsOnTable)
    }

    fun checkPlayerOutput2(output: String, numOfCards: Int, numOfCardsOnTable : Int, topCard: String): ErrorData {
        var position = if (numOfCardsOnTable == 0) checkOutput(output.lowercase(), 0, "No cards on the table".lowercase())
        else checkOutput(output.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Player turn: Wrong message for number of cards or the top card.")

        position = checkOutput(output.lowercase(), position, "Cards in hand:".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong cards in hand message.")
        val cardsInHand = output.substring(position).lines().map { it.trim() }.firstOrNull() { it != "" }
            ?: return ErrorData(false, "Wrong cards in hand message.")
        if (!checkOIfValidCardsInHand(cardsInHand, numOfCards)) return ErrorData(false, "Wrong cards in hand message.")
        val listCardsInHand = cardsInHand.split(" ").map { it.substring(2) }
        var strCardsInHand = ""
        for (card in listCardsInHand) strCardsInHand += "$card "
        if ( !checkIfUniqueCards(strCardsInHand) ) return ErrorData(false, "Player's cards in hand contain duplicate cards.")
        val lastCard = listCardsInHand.last()
        position = output.indexOf(lastCard, position)
        position = checkOutput(output.lowercase(), position + lastCard.length, "Choose a card to play (1-$numOfCards):".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong prompt to choose a card.")
        if (numOfCards == 6 && checkIfSequentialCards(listCardsInHand)) return ErrorData(false, "The card deck isn't shuffled.")
        return ErrorData(true, "", cardsList = listCardsInHand)
    }

    fun checkComputerOutput3(output: String, numOfCardsOnTable : Int, topCard: String, numOfCards: Int): ErrorData {
        var position = if (numOfCardsOnTable == 0) checkOutput(output.lowercase(), 0, "No cards on the table".lowercase())
        else checkOutput(output.lowercase(), 0, "$numOfCardsOnTable cards on the table, and the top card is $topCard".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Computer turn: Wrong output for number of cards or the top card.")

        val cardsStr = output.substring(position).lines().map { it.trim() }.firstOrNull() { it != "" }
            ?: return ErrorData(false, "The computer's cards in hand are not printed.")
        if (cardsStr.isEmpty()) return ErrorData(false, "The computer's cards in hand are not printed.")
        if ( !checkOIfValidCards2(cardsStr, numOfCards) ) return ErrorData(false, "Invalid computer's cards in hand.")
        if ( !checkIfUniqueCards(cardsStr) ) return ErrorData(false, "Computer's cards in hand contain duplicates.")

        val cardsInHand = cardsStr.trim().split(" ")
        position = output.indexOf('\n', output.indexOf(cardsStr))

        position = checkOutput(output.lowercase(), position, "Computer plays".lowercase())
        if ( position  == -1 ) return ErrorData(false, "Wrong computer plays a card message.")

        val endIndex = output.indexOf("\n", position)
        if (endIndex < 0) return ErrorData(false, "Wrong output. Some lines are missing")
        val card = output.substring(position, endIndex).trim()

        val candidates = chooseCards(cardsInHand, topCard)
    //    println("****************")
    //    println("${cardsInHand}")
    //    println("$topCard")
    //    println("$candidates}")
    //    println("****************")
        if (!candidates.contains(card)) return ErrorData(false, "Computer played card $card instead one of $candidates.")

        if (!checkOIfValidCards2(card, 1)) return ErrorData(false, "Computer played an invalid card.")
        if (numOfCards == 6 && checkIfSequentialCards(cardsInHand)) return ErrorData(false, "The card deck isn't shuffled.")
        return ErrorData(true, "", card, cardsInHand)
    }

    fun checkIfSequentialCards(cards: List<String>): Boolean {
        if (cards.size < 2) return false

        val suit = getSuit(cards.first())
        var hasSameSuit = true
        for (index in 1 until cards.size) if (suit != getSuit(cards[index])) hasSameSuit = false
        if (!hasSameSuit) return false

        val ranks = listOf("a", "2", "3", "4", "5", "6", "7", "8", "9", "10", "j", "q", "k")
        var initialRank = ranks.indexOf( getRank( cards.first() ).lowercase() )
        var sequentialUp = true
        for (index in 1 until cards.size) {
            val nextIndex = initialRank++
            if (initialRank > 12) initialRank = 0
            if (initialRank != ranks.indexOf( getRank( cards[index] ).lowercase() ))
                sequentialUp = false
        }

        initialRank = ranks.indexOf( getRank( cards.first() ).lowercase() )
        var sequentialDown = true
        for (index in 1 until cards.size) {
            val nextIndex = initialRank--
            if (initialRank < 0) initialRank = 12
            if (initialRank != ranks.indexOf( getRank( cards[index] ).lowercase() ))
                sequentialDown = false
        }

        return sequentialUp || sequentialDown
    }

    fun getRankSuit(card:String): Pair<String, String> {
        return if (card.length == 2) Pair(card.substring(0, 1), card.substring(1, 2))
        else Pair(card.substring(0, 2), card.substring(2, 3))
    }

    fun countPoints(cards: List<String>): Int {
        val ranks = listOf("A", "10", "J", "Q", "K")
        var count = 0
        for (card in cards) {
            val rank = if (card.length == 2) card.substring(0, 1)
            else card.substring(0, 2)
            if (rank in ranks) count++
        }
        return count
    }

    fun chooseCards(cardsInHand: List<String>, topCard: String): List<String> {
        // Only one card at hand
        if (cardsInHand.size == 1) return cardsInHand

        // No cards on the table. Choose first same suit, then same rank, then random
        if (topCard == "") {
            var cardsToPlay = getSameSuit(cardsInHand)
            if (cardsToPlay.isNotEmpty()) return cardsToPlay
            cardsToPlay = getSameRank(cardsInHand)
            if (cardsToPlay.isNotEmpty()) return cardsToPlay
            else return cardsInHand
        }

        // Get candidate cards
        var candidates = mutableListOf<String>()
        val topRank = getRank(topCard)
        val topSuit = getSuit(topCard)
        for (card in cardsInHand) {
            if (getRank(card) == topRank || getSuit(card) == topSuit) candidates.add(card)
        }

        if (candidates.size == 0) {                       // No candidate cards
            var cardsToPlay = getSameSuit(cardsInHand)
            if (cardsToPlay.isNotEmpty()) return cardsToPlay
            cardsToPlay = getSameRank(cardsInHand).toMutableList()
            if (cardsToPlay.isNotEmpty()) return cardsToPlay
            else return cardsInHand
        }
        else if (candidates.size == 1) {                // Just one candidate card
            return candidates
        } else {                                          // Two or more candidate cards
            var cardsToPlay = getSameSuit(candidates)
            if (cardsToPlay.isNotEmpty()) return cardsToPlay
            cardsToPlay = getSameRank(candidates)
            if (cardsToPlay.isNotEmpty()) return cardsToPlay
            else return candidates
        }
    //    return cardsInHandComputer
    }

    fun getSameSuit(cards: List<String>): List<String> {
        val similarCards = mutableListOf<String>()
        for (suit in listOf("♠", "♥", "♦", "♣")) {
            val c = cards.filter{ getSuit(it) == suit }
            if (c.size > 1) similarCards.addAll(c)
        }
        return similarCards
    }

    fun getSameRank(cards: List<String>): List<String> {
        val similarCards = mutableListOf<String>()
        for (rank in listOf("A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K")) {
            val r = cards.filter { getRank(it) == rank }
            if (r.size > 1) similarCards.addAll(r)
        }
        return similarCards
    }

    fun getRank(card: String): String {
        return if (card.length == 2) card.substring(0, 1)
        else card.substring(0, 2)
    }

    fun getSuit(card: String): String {
        return if (card.length == 2) card.substring(1, 2)
        else card.substring(2, 3)
    }


  learner_created: false
- name: src/indigo/Player.kt
  visible: true
  text: |
    package indigo

    abstract class Player {
        var cardsWon = setOf<Card>()
            private set

        protected val cardsOnHand = ArrayDeque<Card>()

        fun hasCardsOnHand() = !this.cardsOnHand.isEmpty()

        fun drawCards(n: Int, deck: Deck) = this.cardsOnHand.addAll(deck.drawCards(n))

        fun winCards(cards: Collection<Card>, silently: Boolean = false) {
            this.cardsWon += cards
            if (!silently) this.printWinCardsMessage()
        }

        fun playCard(cardOnTop: Card?): Card {
            val chosenCardIndex = this.chooseCardToPlay(cardOnTop)
            val chosenCard = this.cardsOnHand[chosenCardIndex]
            this.cardsOnHand.removeAt(chosenCardIndex)
            return chosenCard
        }

        protected abstract fun chooseCardToPlay(cardOnTop: Card?): Int
        protected abstract fun printWinCardsMessage()
    }

    class HumanPlayer : Player() {
        override fun chooseCardToPlay(cardOnTop: Card?): Int {
            println("Cards in hand: ${this.cardsOnHand.mapIndexed() { i, card -> "${i + 1})$card" }.joinToString(" ")}")
            return this.promptCardIndex()
        }

        override fun printWinCardsMessage() {
            println("Player wins cards")
        }

        private fun promptCardIndex(): Int {
            println("Choose a card to play (1-${this.cardsOnHand.size}):")

            val userInput = readln()
            if (userInput == "exit") {
                println("Game Over")
                kotlin.system.exitProcess(0)
            }

            val userInputInt = userInput.toIntOrNull()
            return if (userInputInt == null || userInputInt !in 1..this.cardsOnHand.size) {
                this.promptCardIndex()
            } else {
                userInputInt - 1
            }
        }
    }

    class ComputerPlayer(private val strategy: Strategy) : Player() {
        override fun chooseCardToPlay(cardOnTop: Card?): Int {
            println(this.cardsOnHand.joinToString(" "))
            val chosenCardIndex = this.strategy.getBestCard(this.cardsOnHand, cardOnTop)
            println("Computer plays ${this.cardsOnHand[chosenCardIndex]}")
            return chosenCardIndex
        }

        override fun printWinCardsMessage() {
            println("Computer wins cards")
        }
    }
  learner_created: true
- name: src/indigo/Card.kt
  visible: true
  text: |
    package indigo

    enum class Rank(val symbol: String) {
        ACE("A"),
        TWO("2"),
        THREE("3"),
        FOUR("4"),
        FIVE("5"),
        SIX("6"),
        SEVEN("7"),
        EIGHT("8"),
        NINE("9"),
        TEN("10"),
        JACK("J"),
        QUEEN("Q"),
        KING("K"),
    }

    enum class Suit(val symbol: String) {
        HEARTS("♥"),
        CLUBS("♣"),
        SPADES("♠"),
        DIAMONDS("♦"),
    }

    class Card(val rank: Rank, val suit: Suit) {
        fun hasSameRank(card: Card) = this.rank == card.rank
        fun hasSameSuit(card: Card) = this.suit == card.suit
        fun hasSameRankOrSuit(card: Card) = this.hasSameRank(card) || this.hasSameSuit(card)

        override fun toString(): String = "${rank.symbol}${suit.symbol}"
    }
  learner_created: true
- name: src/indigo/Deck.kt
  visible: true
  text: |
    package indigo

    class Deck {
        private var cards = listOf<Card>()

        init {
            this.resetCards()
            this.shuffleCards()
        }

        private fun resetCards() {
            this.cards = Rank.values()
                .map { rank -> Suit.values().map { Card(rank, it) } }
                .flatten()
        }

        private fun shuffleCards() {
            this.cards = this.cards.shuffled()
        }

        fun drawCards(n: Int): List<Card> {
            return when (n) {
                !in 1 .. 52 -> throw Exception("Invalid number of cards.")
                !in 1 .. this.cards.size -> throw Exception("The remaining cards are insufficient to meet the request.")
                else -> {
                    val drawnCards = this.cards.slice(0 until n)
                    if (n <= this.cards.lastIndex) {
                        this.cards = this.cards.slice(n .. this.cards.lastIndex)
                    } else {
                        this.cards = emptyList<Card>()
                    }
                    drawnCards
                }
            }
        }

        fun isEmpty() = this.cards.isEmpty()
    }
  learner_created: true
- name: src/indigo/Game.kt
  visible: true
  text: |
    package indigo

    class Game {
        private val deck = Deck()
        private val cardsOnTable = ArrayDeque<Card>()

        private val humanPlayer = HumanPlayer()
        private val computerPlayer = ComputerPlayer(BasicStrategy())

        private var currentPlayer: Player = this.humanPlayer
        private var startingPlayer: Player = this.humanPlayer
        private var lastWinningPlayer: Player? = null

        private fun promptPlayFirst() {
            println("Play first?")

            return when(readln().lowercase()) {
                "yes" -> return
                "no" -> {
                    this.currentPlayer = this.computerPlayer
                    this.startingPlayer = this.computerPlayer
                }
                else -> promptPlayFirst()
            }
        }

        private fun printScore(hasGameEnded: Boolean = false) {
            val humanPlayersWonCards = this.humanPlayer.cardsWon
            val computerPlayersWonCards = this.computerPlayer.cardsWon

            val winningRanks = setOf(Rank.ACE, Rank.TEN, Rank.JACK, Rank.QUEEN, Rank.KING)
            var humanPlayersScore = humanPlayersWonCards.count { it.rank in winningRanks }
            var computerPlayersScore = computerPlayersWonCards.count { it.rank in winningRanks }

            if (hasGameEnded) {
                if (humanPlayersWonCards.size > computerPlayersWonCards.size) {
                    humanPlayersScore += 3
                } else if (humanPlayersWonCards.size < computerPlayersWonCards.size) {
                    computerPlayersScore += 3
                } else {
                    if (this.startingPlayer == this.humanPlayer) humanPlayersScore += 3 else computerPlayersScore += 3
                }
            }

            println("Score: Player $humanPlayersScore - Computer $computerPlayersScore")
            println("Cards: Player ${humanPlayersWonCards.size} - Computer ${computerPlayersWonCards.size}")
        }

        private fun runGameLoop() {
            if (this.cardsOnTable.isEmpty()) {
                println("No cards on the table")
            } else {
                println("${this.cardsOnTable.size} cards on the table, and the top card is ${this.cardsOnTable.last()}")
            }

            if (this.deck.isEmpty() && !this.currentPlayer.hasCardsOnHand()) {
                this.lastWinningPlayer?.winCards(this.cardsOnTable, silently = true) ?:
                        this.startingPlayer.winCards(this.cardsOnTable, silently = true)
                this.printScore(hasGameEnded = true)
                return println("Game Over")
            }

            if (!this.currentPlayer.hasCardsOnHand()) this.currentPlayer.drawCards(6, this.deck)

            val playedCard = this.currentPlayer.playCard(this.cardsOnTable.lastOrNull())
            if (!this.cardsOnTable.isEmpty() && playedCard.hasSameRankOrSuit(this.cardsOnTable.last())) {
                this.currentPlayer.winCards(this.cardsOnTable.plus(playedCard))
                this.lastWinningPlayer = this.currentPlayer
                this.cardsOnTable.clear()
                this.printScore()
            } else {
                this.cardsOnTable.addLast(playedCard)
            }

            this.currentPlayer = if (this.currentPlayer == this.humanPlayer) this.computerPlayer else this.humanPlayer

            println()
            runGameLoop()
        }

        fun start() {
            println("Indigo Card Game")
            this.promptPlayFirst()

            this.cardsOnTable.addAll(this.deck.drawCards(4))
            println("Initial cards on the table: ${this.cardsOnTable.joinToString(" ")}\n")

            runGameLoop()
        }
    }
  learner_created: true
- name: src/indigo/Strategy.kt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16512#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Thu, 06 Oct 2022 22:48:56 UTC
record: 5
